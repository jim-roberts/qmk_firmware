/* Copyright 2020 Ungodly Design <hello@ungodly.design>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/** @defgroup jr_launchpad_keymap */

/** @addtogroup jr_launchpad_keymap
  * @brief Keymap
  *
  * @details
  *  Build :
  *     qmk compile -kb  ungodly/launch_pad -km jimr
  *  Clean :
  *     qmk compile -kb  ungodly/launch_pad -km clean
  *
  * \par Modification History
  *    Date     | Initials | Notes
  *    -------- | -------- | -----------------------------------------------------------------------
  *    11/06/21 |   JR     | Initial File
  * @{
*/

#include QMK_KEYBOARD_H
#include "analog.h"
#include "qmk_midi.h"

#include "quantum.h"
#include "action_layer.h"
#include "action_util.h"

#define DEBUG_SOURCES

#ifdef DEBUG_SOURCES
	#pragma GCC diagnostic push
	#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#endif

#if 0
//oled
typedef enum {
    OLED_MODE_IDLE = 0,
    OLED_MODE_VOLUME_UP = 1,
    OLED_MODE_VOLUME_DOWN = 2,
	kOLED_NUM_MODES
} oled_mode_t;

static const char PROGMEM oled_mode_messages[ kOLED_NUM_MODES ][15] = {
    "",
    "Volume Up",
    "Volume Down",
};

static const char PROGMEM oled_mode_icons[ kOLED_NUM_MODES ][3][5] = {
    {{128,129,130,131,0},{160,161,162,163,0},{192,193,194,195,0}},
    {{132,133,134,135,0},{164,165,166,167,0},{196,197,198,199,0}},
    {{136,137,138,139,0},{168,169,170,171,0},{200,201,202,203,0}},
};


void render_status_mode_message(void) {
    // Printing state icon with message
    oled_write_P(oled_mode_icons[oled_mode][0], false);
    oled_write_P(PSTR("\n"), false);
    oled_write_P(oled_mode_icons[oled_mode][1], false);
    oled_write_P(PSTR("  "), false);
    //oled_write_P(oled_mode_messages[oled_mode], false);
    //oled_write_P(PSTR("\n"), false);
    oled_write_P(oled_mode_icons[oled_mode][2], false);
    oled_write_P(PSTR("\n\n"), false);
}
#endif

#define ___X___             KC_NO               /* do nothing */
#define MIC_MUTE_KEY        KC_F24
#define MIC_UNMUTE_KEY      KC_F23
#define PSCR_PASTE_KEY      KC_F20  /*Pass to autohotkey script : prntsrc, open irfanview and paste*/

/** @ingroup jr_launchpad_keymap
*   @brief Our custom keycode enumeration.*/
enum custom_keycodes {
    KC_LUP = SAFE_RANGE, //cycle layers in up direction
    KC_LDN, //cycle layers in down direction
	KC_WIN_ZOOM_IN,
	KC_WIN_ZOOM_OUT
};

/** @ingroup jr_launchpad_keymap
*   @brief Our layer enumeration.*/
typedef enum {
    kLayerBase = 0,
    kLayerNum,
    kLayerRGB,
    kNumLayers
} kLayerEnum;


#if defined( RGB_MATRIX_ENABLE ) || defined ( RGBLIGHT_ENABLE )
	/*
	//For animation choices, coordinate with config.h ( RGB_MATRIX )
	 *
	 *
	RGB_MODE_PLAIN			Static (no animation) mode
	RGB_MODE_BREATHE		Breathing animation mode
	RGB_MODE_RAINBOW		Rainbow animation mode
	RGB_MODE_SWIRL			Swirl animation mode
	RGB_MODE_SNAKE			Snake animation mode
	RGB_MODE_KNIGHT			“Knight Rider” animation mode
	RGB_MODE_XMAS			Christmas animation mode
	RGB_MODE_GRADIENT		Static gradient animation mode
	RGB_MODE_RGBTEST		Red, Green, Blue test animation mode
	RGB_MODE_TWINKLE	    Twinkle animation mode
	 *
	 *
	 *
	*/

	//How long (in ms) to wait between animation steps
	//param 1 - on time
	//param 2 - off time
	//param 3 - delay between off to on
	const uint8_t RGBLED_BREATHING_INTERVALS[] PROGMEM =        {30, 20, 10, 5};

	/** @ingroup jr_madnoodle_keymap
	*   @brief define storage type for led color info */
	typedef struct {
		uint8_t hue;    /**< HUE           */
		uint8_t sat;    /**< Saturation    */
		uint8_t val;    /**< Value         */
	} sHSV;

	/** @ingroup jr_madnoodle_keymap
	*   @brief define storage type to hold layer led color and modes
	*
	*   @details We include an explicit layer member to avoid implicit association of enumerated order to any table ordering
	*
	*/
	typedef struct {
		kLayerEnum   layer;    /**< layer this color and mode are applicable to  */
		sHSV         color;    /**< color for layer                              */
		uint16_t     mode;     /**< RGB mode for layer, see RGBLIGHT_ANIMATIONS  */
	} sLedInfo;


	#define MY_BLUE     HSV_BLUE
	#define MY_GREEN    HSV_GREEN

	// 17.99  , 100% , 100%
	#define MY_ORANGE   0x07 , 0xFF,  0xFF /*HSV_ORANGE*/
	//185 , 100% , 100%
	//#define MY_PURPLE   185 , PERC_2_BYTE( 100 ) , PERC_2_BYTE( 100 )
	#define MY_PURPLE   0xB9 , 0xFF , 0xFF /*HSV_PURPLE*/

	#define MY_DEFAULT_COLOR		MY_GREEN

	#ifdef RGB_MATRIX_ENABLE			/*  RGB_MATRIX vs RGB_LIGHT */
		#define RGB_INCR_HUE()    rgb_matrix_increase_hue_noeeprom()
		#define RGB_DECR_HUE()    rgb_matrix_decrease_hue_noeeprom()

		#define SET_COLOR( h,s,v )      rgb_matrix_sethsv_noeeprom( (uint16_t) h, (uint8_t) s, (uint8_t) v );
		#define SET_LED_MODE( mod )     rgb_matrix_mode_noeeprom( mod );

		#define ENABLE_RGB()            rgb_matrix_enable_noeeprom();


		/*
		* See config.h
		*/
		#define DEFAULT_LED_MODE   		RGB_MATRIX_SOLID_REACTIVE
		#define RGB_BREATHE				RGB_MATRIX_BREATHING

	#else //RGB_LIGHT_ENABLE

		#define RGB_INCR_HUE()    rgblight_increase_hue_noeeprom()
		#define RGB_DECR_HUE()    rgblight_decrease_hue_noeeprom()

		#define SET_COLOR( h,s,v )      rgblight_sethsv_noeeprom( h,s,v );
		#define SET_LED_MODE( mod )     rgblight_mode_noeeprom( (uint16_t)mod ) ;

		#define ENABLE_RGB()            rgblight_enable_noeeprom();

		/*
		choices for rgb animations , See: rgblight.h
		RGBLIGHT_MODE_STATIC_LIGHT     : All leds on w/current rgb color(s)
		RGBLIGHT_MODE_BREATHING        : Slowly brighten and dim all leds at same time w/current rgb color(s)
		RGBLIGHT_MODE_RAINBOW_MOOD     : All leds on and all slowly cycle through colors
		RGBLIGHT_MODE_RAINBOW_SWIRL    : Same effect as RGBLIGHT_MODE_STATIC_GRADIENT ( might be due to limted # of leds )
		RGBLIGHT_MODE_SNAKE            : One led on at a time, moving in a circular pattern
		RGBLIGHT_MODE_KNIGHT           : Knight rider /cylon light effect w/current rgb color(s)
		RGBLIGHT_MODE_STATIC_GRADIENT  : Each led on but assigned a different color from the spectrum
		RGBLIGHT_MODE_TWINKLE          : Slow brighten and dim one led at a time, in sequence w/current rgb color(s)
		RGBLIGHT_MODE_ALTERNATING      : Alternate halves ( on/off ) w/current rgb color(s)
		RGBLIGHT_MODE_CHRISTMAS        : Alternate halves with Red and Green colors
		RGBLIGHT_MODE_RGB_TEST
		*/

		#define DEFAULT_LED_MODE   		RGBLIGHT_MODE_STATIC_LIGHT
		#define RGB_BREATHE				RGBLIGHT_MODE_BREATHING
	#endif

    /** @ingroup jr_launchpad_keymap
	*   @brief Our primary container for associating a layer to its color and mode
	*/
	sLedInfo g_led_info[ kNumLayers ] = {
		{ .layer = kLayerBase, .color = { MY_GREEN    }, .mode = RGB_BREATHE },
		{ .layer = kLayerNum,  .color = { MY_ORANGE   }, .mode = DEFAULT_LED_MODE },
		{ .layer = kLayerRGB,  .color = { MY_PURPLE   }, .mode = DEFAULT_LED_MODE },
	};

	#define LAUNCHPAD_RGB_ENABLED

#endif


#ifdef LAUNCHPAD_RGB_ENABLED

/*  @ingroup jr_launchpad_keymap
*   @brief  Find layer led info within our led info table
*
*   @details Find layer led info within our led info table.
*            Used primarily to locate the section of memory we which to change ( color and mode relative to layer )
*            Table entries do not need to follow enumeration order.
*            We do this to avoid implicit association of enumerated order to any table ordering
*
*   @param  layer  [in] :  layer to locate
*
*   /sa g_led_info
*
*   @return  index in table where layer info is stored
*/
uint16_t find_layer_table_index( kLayerEnum layer ){
    uint16_t idx;

    for( idx = 0 ; idx < kNumLayers ; ++idx ){
        if ( layer == g_led_info[ idx ].layer )
            return idx;
    }

    return (uint16_t)kLayerBase; //default
}
#endif

/** @ingroup jr_launchpad_keymap
*   @brief  Manage application of RGB ( mode and color ) when transitioning to a new layer.
*
*   @param  new_layer  [in] :  new layer to move into
*
*   @return  --
*/
void move_to_layer( kLayerEnum new_layer ){


#ifdef LAUNCHPAD_RGB_ENABLED
    //affect RGB to indicate layer
    sHSV *pcolor;
    sLedInfo * pInfo;
    uint16_t *pmode;

    pInfo = &g_led_info[ find_layer_table_index( new_layer ) ];
    pcolor = &pInfo->color;
    pmode = &pInfo->mode;

    SET_COLOR( pcolor->hue , pcolor->sat, pcolor->val);
    SET_LED_MODE( *pmode );
#endif

    layer_move(new_layer);
}


/** @ingroup jr_launchpad_keymap
*   @brief  Manage simple state machine for advancing to next layer while allowing for rollover
*
*   @param  curr_layer  [in] :  current layer
*
*   @return  --
*/
void move_to_next_layer( kLayerEnum curr_layer ){

	kLayerEnum next_layer = ++curr_layer;

   if( next_layer == kNumLayers ){
       next_layer = kLayerBase;
   }

    move_to_layer( next_layer );
};

/** @ingroup jr_launchpad_keymap
*
*   @brief Our custom keycode handler
*
*   @details https://beta.docs.qmk.fm/using-qmk/guides/custom_quantum_functions
*    " If these functions return false QMK will skip the normal key handling, and"
*     "it will be up to you to send any key up or down events that are required. "
*
*   @param  keycode : keycode value as represented in our "custom keycodes" enumeration
*   @param  record  : ??
*
*   @return true to indicate finished handling keypress event
*   */
bool process_record_user(uint16_t keycode, keyrecord_t *record) {
  switch (keycode) {
  case KC_LUP:
    if(record->event.pressed) {
    	move_to_next_layer( get_highest_layer(layer_state) );
    }
    return false;
  case KC_WIN_ZOOM_IN:
	  tap_code16( LCTL( LSFT(KC_EQL)  ) );
	  return false;
  case KC_WIN_ZOOM_OUT:
	  tap_code16( LCTL( KC_MINS ) );
	  return false;
  default:
    return true;
  }

  return true;
}

/*! @brief primary container for defining key mapping. */
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
/* Keymap _BL: (Base Layer) Default Numpad Layer
 * ,-------------------.
 * |NUML| /  | *  |LAYR |
 * |----|----|----|-----|
 * | 7  | 8  | 9  |  -  |
 * |----|----|----|-----|
 * | 4  | 5  | 6  |  +  |
 * |----|----|----|-----|
 * | 1  | 2  | 3  | En  |
 * |----|----|----|-----|
 * | 0  | 0  | .  | En  |
 * `--------------------'
 */
 [kLayerBase] = LAYOUT_ortho_5x4(
KC_NUMLOCK,   KC_PSLS,  KC_PAST, /*LT(2, KC_LUP)*/KC_LUP,
   KC_P7,    KC_P8,    KC_P9,        KC_PMNS,
   KC_P4,    KC_P5,    KC_P6,        KC_PPLS,
   KC_P1,    KC_P2,    KC_P3,        KC_PENT,
   KC_P0,    KC_P0,  KC_PDOT,        KC_PENT
 ),

/* Keymap _NV: Navigation layer
* ,-------------------.
* |BACK|    |    |LAYR |
* |----|----|----|----|
* |HOME| UP |PGUP|    |
* |----|----|----|----|
* |LEFT|    |RIGH|    |
* |----|----|----|----|
* |END |DOWN|PGDN| En |
* |----|----|----|----|
* |INS |INS |DEL | En |
* `-------------------'
*/
[kLayerNum] = LAYOUT_ortho_5x4(
  KC_BSPC, XXXXXXX,  XXXXXXX,     KC_LUP,
  KC_HOME,   KC_UP,   KC_PGUP,    XXXXXXX,
  KC_LEFT, XXXXXXX,   KC_RGHT,    XXXXXXX,
  KC_END,  KC_DOWN,   KC_PGDN,    KC_PENT,
  KC_INS,   KC_INS,   KC_DEL,     KC_PENT
),

/* Keymap _FN: RGB Function Layer
 * ,-------------------.
 * |RTOG|    |    |LAYR|
 * |----|----|----|----|
 * |HUD |HUI |    |RGBP|
 * |----|----|----|----|
 * |SAD |SAI |    |RMOD|
 * |----|----|----|----|
 * |VAD |VAS |    |    |
 * |----|----|----|----|
 * |RST |RST |    |    |
 * `-------------------'
 */
  [kLayerRGB] = LAYOUT_ortho_5x4(
    RGB_TOG,  XXXXXXX,  XXXXXXX,   KC_LUP,
    RGB_HUD,  RGB_HUI,  XXXXXXX,   RGB_M_P,
    RGB_SAD,  RGB_SAI,  XXXXXXX,   RGB_MOD,
    RGB_VAD,  RGB_VAI,  XXXXXXX,   XXXXXXX,
      RESET,    RESET,  XXXXXXX,   XXXXXXX
  ),
};

// (Optional) Rotary Encoder, Volume Control
bool encoder_update_user(uint8_t index, bool clockwise) {
  if (clockwise) {
     // tap_code(KC_PGUP);
      tap_code16( LCTL( LSFT(KC_EQL)  ) );
  } else {
    //  tap_code(KC_PGDN);
      tap_code16( LCTL( KC_MINS ) );
  }

  return true;
}

void matrix_init_user(void) {
	analogReference(ADC_REF_POWER);

	/* Force Numlock on */
	if (!host_keyboard_led_state().num_lock) {
		 tap_code(KC_NUMLOCK);
	}
}


void do_slider_up(void){
	//tap_code(KC_VOLU);
	//TODO - oled image update
}

void do_slider_down(void){
	//tap_code(KC_VOLD);
	//TODO - oled image update
}

uint8_t divisor = 0;
int16_t pot_oldVal = 0;

#define POT_TOLERANCE 20  /* keep raw adc value from dumping */

//#define ADJUSTED( x )  ( x / 10 )
#define ADJUSTED( x )  ( x )

void do_slider(void){ //this slider ranges in adc values of 0 to 1023

	int16_t pot_val    = 0;
	int16_t raw_val    = 0;
	int32_t diff;
	int8_t idx;

	char raw_pot_val_str[6];
	char filt_pot_val_str[6];

#if 0
	//primitive sampling soln
	if (divisor++) { // only run the slider function 1/256 times it's called ( rollover of 8bit val )
	  return;
	}
#endif

	raw_val   = (analogReadPin(SLIDER_PIN));

	pot_val = ADJUSTED(raw_val);

	diff = abs(pot_val - pot_oldVal);

	if ( diff > POT_TOLERANCE ) {

		if( pot_val > pot_oldVal ){
			do_slider_up();
		} else if ( pot_val < pot_oldVal ) {
			do_slider_down();
		}

		pot_oldVal = pot_val;

	  //oled debug of pot value
#if 0
		sprintf( pot_val_str , "%d" , pot_val ); //large codespace consumer
#else
		//raw
		if( raw_val >= 0 ){
			raw_pot_val_str[0] = '+';
		} else {
			raw_pot_val_str[0] = '-';
		}

		raw_pot_val_str[5] = '\0';
		for(idx = 4 ; idx > 0 ; --idx ){
			raw_pot_val_str[ idx ] = '0' + raw_val % 10;
			raw_val = raw_val / 10;
		}

		//filt
		if( pot_val >= 0 ){
			filt_pot_val_str[0] = '+';
		} else {
			filt_pot_val_str[0] = '-';
		}

		filt_pot_val_str[5] = '\0';
		for(idx = 4 ; idx > 0 ; --idx ){
			filt_pot_val_str[ idx ] = '0' + pot_val % 10;
			pot_val = pot_val / 10;
		}
#endif
		oled_write(raw_pot_val_str, false);

		//oled_write_P(PSTR("\n"), false);
		//oled_write(filt_pot_val_str, false);
	}

}

void matrix_scan_user(void) {

	do_slider();

}


/*
*   @brief  Kickstart RGB effect
*
*   @return  --
*/
void keyboard_post_init_user(void) {

#ifdef LAUNCHPAD_RGB_ENABLED
	ENABLE_RGB();

#ifdef RGB_MATRIX_ENABLE
	rgb_matrix_sethsv_noeeprom( MY_DEFAULT_COLOR );
#else
	rgblight_sethsv_noeeprom( MY_DEFAULT_COLOR );
#endif
	SET_LED_MODE( DEFAULT_LED_MODE );
#endif
};


// 0.91" OLED, 128x32 resolution
#ifdef OLED_ENABLE

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
	return OLED_ROTATION_180;
}

static void render_rocket_logo(void) {
  static const char PROGMEM rocket_logo[]={
    // Rocket Screen
    // 'home', 128x32px
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0x80, 0x80, 0xc0, 0x40, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x20, 0x50, 0x50, 0x90,
    0x10, 0x10, 0x20, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x10, 0x10, 0xf0, 0x10, 0x10, 0x08, 0x08, 0x08, 0x04, 0x04,
    0x04, 0xfc, 0xfc, 0xfc, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0xfc, 0x7c, 0x7e, 0x7e, 0x7f,
    0x81, 0x81, 0x81, 0x81, 0xff, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xff,
    0xff, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0x01, 0x01, 0x01, 0xf9, 0x01, 0xf9, 0x01,
    0xf9, 0x01, 0xf9, 0x01, 0x01, 0x01, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe6,
    0xe6, 0xe6, 0xe6, 0xe6, 0xff, 0x8c, 0x52, 0x52, 0x52, 0xde, 0x84, 0x08, 0x84, 0x08, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x04, 0x04,
    0x05, 0x05, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x04, 0x04, 0x07, 0x04, 0x04, 0x08, 0x08, 0x08, 0x10, 0x10,
    0x10, 0x1f, 0x1f, 0x1f, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1f, 0x10, 0x20, 0x20, 0x40,
    0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7f,
    0x7f, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x40, 0x40, 0x40, 0x4a, 0x44, 0x4a, 0x40,
    0x4f, 0x40, 0x4f, 0x40, 0x40, 0x40, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x9c,
    0x9c, 0x9c, 0x9c, 0x1c, 0xff, 0x31, 0x4a, 0x4a, 0x4a, 0x7b, 0x10, 0x21, 0x10, 0x21, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };
  oled_write_raw_P(rocket_logo, sizeof(rocket_logo));
}
static void render_nav_logo(void) {
  static const char PROGMEM nav_logo[]={
    // Navigation Screen
    // 'navigation', 128x32px
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x40,
    0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x20, 0x50, 0x50, 0x90,
    0x10, 0x10, 0x20, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x10, 0xc8, 0x28, 0x28, 0x28, 0xc8, 0x10,
    0xb0, 0x10, 0x20, 0x20, 0x20, 0x40, 0x40, 0x40, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x20, 0x20,
    0x20, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0xa1, 0x09, 0xe1,
    0xf3, 0x29, 0x05, 0x85, 0xe5, 0xe5, 0xc5, 0x89, 0x92, 0xe4, 0x08, 0xf0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x88, 0x44,
    0x44, 0x22, 0xe2, 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x04, 0x04,
    0x05, 0x05, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x09, 0x0b, 0x0b, 0x0b, 0x09, 0x04,
    0x06, 0x04, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02, 0x02,
    0x02, 0x04, 0x04, 0x04, 0x08, 0x08, 0x08, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0x42, 0x48, 0x43,
    0x66, 0x4e, 0x53, 0x51, 0x51, 0x53, 0x53, 0x49, 0x24, 0x13, 0x08, 0x07, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x91,
    0x91, 0x52, 0x53, 0x34, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };
  oled_write_raw_P(nav_logo, sizeof(nav_logo));
}
static void render_light_logo(void) {
  static const char PROGMEM light_logo[]={
    // RGB Screen
    // 'rgb', 128x32px
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x9c, 0x80, 0x80,
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80,
    0x80, 0x40, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x20, 0x50, 0x50, 0x90,
    0x10, 0x10, 0x20, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x80, 0x80, 0x00, 0x00, 0xe0, 0x19, 0x04, 0x62, 0x11, 0x09, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x01, 0x02, 0x04, 0x19, 0x10, 0x10, 0xf0, 0x00, 0x00, 0xf0, 0x00, 0xf0, 0xe0, 0xc0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x24, 0x04,
    0x07, 0xe4, 0x24, 0x24, 0xc7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x04, 0x04,
    0x05, 0x05, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x88, 0x30, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x80, 0x40, 0x60, 0x30, 0x98, 0x08, 0x08, 0x0f, 0x00, 0x00, 0x0f, 0x00, 0x0f, 0x07, 0x03,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x22, 0x24,
    0x24, 0xc4, 0x44, 0x22, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1d, 0x01, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x02, 0x02,
    0x02, 0x03, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };
  oled_write_raw_P(light_logo, sizeof(light_logo));
}

uint8_t prev_layer = 255;

bool oled_task_user(void) {

  uint8_t latest_layer = get_highest_layer(layer_state);

  if( latest_layer != prev_layer  )	{
	  prev_layer = latest_layer;
	  switch ( latest_layer ) {
		case 0:
		  render_rocket_logo();
		  break;
		case 1:
		  render_nav_logo();
		  break;
		case 2:
		  render_light_logo();
		  break;
		default:
		  // Or use the write_ln shortcut over adding '\n' to the end of your string
		  oled_write_ln_P(PSTR(" UND"), false);
		  break;
		}
  }

  return false;
}
#endif

#ifdef DEBUG_SOURCES
	#pragma GCC diagnostic pop
#endif
/** @} */
